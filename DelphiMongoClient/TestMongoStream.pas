unit TestMongoStream;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Classes, MongoStream, MongoDB, GridFS, TestMongoDB, TestGridFS;

{$I MongoC_defines.inc}

type
  // Test methods for class TMongoStream

  TestTMongoStream = class(TestGridFSBase)
  private
    FMongoStream: TMongoStream;
    procedure CheckMongoStreamPointer;
    procedure CreateTestFile(ACreateMode: Boolean = True);
    {$IFDEF DELPHI2007}
    procedure TestSeek_Int64(AOrigin: TSeekOrigin; AOffset, AbsExpected: Int64);
    {$ENDIF}
    procedure TestSeek_Int32(AOrigin: Word; AOffset: Longint; AbsExpected: Int64);
  protected
    procedure InternalRunMultiThreaded(AMethodAddr: Pointer; ALoops: Integer);
    function StandardRemoteFileName: AnsiString; override;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetSizeIn32;
    procedure TestSetSizeInt32;
    {$IFDEF DELPHI2007}
    procedure TestSetSizeInt64;
    {$ENDIF}
    procedure TestCreateStream;
    procedure TestCreateStreamAndOpenWithDifferentCase;
    procedure TestCreateStreamWithPrefix;
    procedure TestRead;
    procedure TestSeekFromCurrentInt32;
    procedure TestSeekFromEndInt32;
    procedure TestSeekFromBeginningInt32;
    {$IFDEF DELPHI2007}
    procedure TestSeekFromBeginningInt64;
    procedure TestSeekFromCurrentInt64;
    procedure TestSeekFromEndInt64;
    {$ENDIF}
    procedure TestSeekPastTheEndOfFile;
    procedure TestStreamStatusFlag;
    procedure TestStressFourThreads;
    procedure TestStressWriteReads;
    procedure TestWrite;
    procedure TestWriteRead50MB;
    procedure TestWriteRed50MBFourThreads;
  end;

implementation

uses
  uFileManagement, FileCtrl, SysUtils, MongoBson;

const
  FILESIZE = 512 * 1024;
  SMALLER_SIZE = 1024;
  FEW_BYTES_OF_DATA : AnsiString = 'this is just a few bytes of data';

type
  TTestProc = procedure of object;
  TMongoStreamThread = class(TThread)
  private
    FErrorMessage: AnsiString;
    FLoops: Integer;
    FTestMongoStream: TestTMongoStream;
    FTestProc: Pointer;
  public
    constructor Create(ATestProc: Pointer; ALoops: Integer);
    destructor Destroy; override;
    procedure Execute; override;
    property ErrorMessage: AnsiString read FErrorMessage;
  end;

procedure TestTMongoStream.CheckMongoStreamPointer;
begin
  Check(FMongoStream <> nil, 'FMongoStream should be <> nil');
end;

procedure TestTMongoStream.CreateTestFile(ACreateMode: Boolean = True);
var
  AMode : TMongoStreamModeSet;
begin
  if ACreateMode then
    AMode := [msmWrite, msmCreate]
  else AMode := [msmWrite];
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, AMode, True);
end;

procedure TestTMongoStream.InternalRunMultiThreaded(AMethodAddr: Pointer;
    ALoops: Integer);
var
  AThreads : array [0..3] of TMongoStreamThread;
  i : integer;
  AErrorMessages : AnsiString;
begin
  AErrorMessages := '';
  for i := Low(AThreads) to High(AThreads) do
    AThreads[i] := nil;
  for i := Low(AThreads) to High(AThreads) do
    AThreads[i] := TMongoStreamThread.Create(AMethodAddr, ALoops);
  try
    for i := Low(AThreads) to High(AThreads) do
      AThreads[i].Resume;
    for i := Low(AThreads) to High(AThreads) do
      AThreads[i].WaitFor;
    for i := Low(AThreads) to High(AThreads) do
      if AThreads[i].ErrorMessage <> '' then
        AErrorMessages := AErrorMessages + AThreads[i].ErrorMessage + #13#10;
    if AErrorMessages <> '' then
      Fail(AErrorMessages);
  finally
    for i := Low(AThreads) to High(AThreads) do
      if AThreads[i] <> nil then
        AThreads[i].Free;
  end;
end;

procedure TestTMongoStream.SetUp;
begin
  inherited;
end;

function TestTMongoStream.StandardRemoteFileName: AnsiString;
begin
  Result := IntToStr(Int64(Self)) + inherited StandardRemoteFileName;
end;

procedure TestTMongoStream.TearDown;
begin
  if FMongoStream <> nil then
    begin
      FMongoStream.Free;
      FMongoStream := nil;
    end;
  inherited;
end;

procedure TestTMongoStream.TestGetSizeIn32;
var
  ReturnValue: Int64;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA));
  ReturnValue := FMongoStream.Size;
  CheckEquals(length(FEW_BYTES_OF_DATA), ReturnValue, 'Expected file size doesn''t match');
end;

procedure TestTMongoStream.TestSetSizeInt32;
var
  NewSize: Integer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA));
  NewSize := length(FEW_BYTES_OF_DATA) - 2;
  FMongoStream.Size := NewSize;
  CheckEquals(NewSize, FMongoStream.Position, 'Position should be at the end of the file');
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], True);
  CheckEquals(NewSize, FMongoStream.Size, 'New size was not taken by MongoStream');
end;

{$IFDEF DELPHI2007}
procedure TestTMongoStream.TestSetSizeInt64;
var
  NewSize: Int64;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA));
  NewSize := length(FEW_BYTES_OF_DATA) - 2;
  FMongoStream.Size := NewSize;
  CheckEquals(NewSize, FMongoStream.Position, 'Position should be at the end of the file');
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], True);
  CheckEquals(NewSize, FMongoStream.Size, 'New size was not taken by MongoStream');
end;
{$ENDIF}

procedure TestTMongoStream.TestCreateStream;
var
  AFileName: AnsiString;
  ADB: AnsiString;
begin
  ADB := FSDB;
  AFileName := StandardRemoteFileName;
  FMongoStream := TMongoStream.Create(FMongo, ADB, AFileName, [msmCreate, msmWrite], False);
  CheckMongoStreamPointer;
end;

procedure TestTMongoStream.TestCreateStreamAndOpenWithDifferentCase;
var
  AFileName: AnsiString;
  ADB: AnsiString;
begin
  ADB := FSDB;
  AFileName := StandardRemoteFileName;
  FMongoStream := TMongoStream.Create(FMongo, ADB, AFileName, [msmCreate, msmWrite], False);
  CheckMongoStreamPointer;
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, ADB, AnsiString(LowerCase(AFileName)), [], False);
end;

procedure TestTMongoStream.TestCreateStreamWithPrefix;
var
  AFileName: AnsiString;
  APrefix: AnsiString;
  ADB: AnsiString;
begin
  ADB := FSDB;
  AFileName := StandardRemoteFileName;
  APrefix := 'prefix_test';
  FMongoStream := TMongoStream.Create(FMongo, ADB, AFileName, APrefix, [msmCreate], True, False);
  CheckMongoStreamPointer;
end;

procedure TestTMongoStream.TestRead;
var
  ReturnValue: Integer;
  Count: Integer;
  Buffer: array [0..SMALLER_SIZE - 1] of AnsiChar;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, Count);
  FMongoStream.Position := 0;
  ReturnValue := FMongoStream.Read(Buffer, Count);
  CheckEquals(Count, ReturnValue, 'Number of bytes read dont''t match');
  Check(CompareMem(@Buffer, PAnsiChar(FEW_BYTES_OF_DATA), Count), 'Memory read don''t match data written');
end;

procedure TestTMongoStream.TestSeekFromCurrentInt32;
begin
  TestSeek_Int32(soFromCurrent, -1, length(FEW_BYTES_OF_DATA) - 1);
end;

procedure TestTMongoStream.TestSeekFromEndInt32;
begin
   TestSeek_Int32(soFromEnd, -2, length(FEW_BYTES_OF_DATA) - 2);
end;

procedure TestTMongoStream.TestSeekFromBeginningInt32;
begin
  TestSeek_Int32(soFromBeginning, 5, 5);
end;

procedure TestTMongoStream.TestSeek_Int32(AOrigin: Word; AOffset: Longint;
    AbsExpected: Int64);
var
  ReturnValue: Integer;
  Origin: Word;
  Offset: Integer;
  Buffer: array [0..SMALLER_SIZE - 1] of AnsiChar;
  Count : integer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, Count);
  Offset := AOffset;
  Origin := AOrigin;
  ReturnValue := FMongoStream.Seek(Offset, Origin);
  CheckEquals(AbsExpected, ReturnValue, 'Return value from Seek not what expected');
  CheckEquals(Count - AbsExpected, FMongoStream.Read(Buffer, Count), 'Number of bytes read after first Seek not what expected');
  Check(CompareMem(@Buffer, @PAnsiChar(FEW_BYTES_OF_DATA)[AbsExpected], Count - AbsExpected), 'Data read doesn''t match');
end;

{$IFDEF DELPHI2007}
procedure TestTMongoStream.TestSeekFromBeginningInt64;
begin
  TestSeek_Int64(soBeginning, 5, 5);
end;

procedure TestTMongoStream.TestSeekFromCurrentInt64;
begin
  TestSeek_Int64(soCurrent, -1, length(FEW_BYTES_OF_DATA) - 1);
end;

procedure TestTMongoStream.TestSeekFromEndInt64;
begin
  TestSeek_Int64(soEnd, -2, length(FEW_BYTES_OF_DATA) - 2);
end;
{$ENDIF}

procedure TestTMongoStream.TestSeekPastTheEndOfFile;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA)), 'Write didn''t return that I wrote the same amount of bytes written');
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Seek(length(FEW_BYTES_OF_DATA) + 1, {$IFDEF DELPHI2007} soBeginning {$ELSE} soFromBeginning {$ENDIF}), 'Should not allow seeking past the end of file');
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Position, 'Should not allow seeking past the end of file');
end;

{$IFDEF DELPHI2007}
procedure TestTMongoStream.TestSeek_Int64(AOrigin: TSeekOrigin; AOffset,
    AbsExpected: Int64);
var
  ReturnValue: Int64;
  Origin: TSeekOrigin;
  Offset: Int64;
  Buffer: array [0..SMALLER_SIZE - 1] of AnsiChar;
  Count : integer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, Count);
  Offset := AOffset;
  Origin := AOrigin;
  ReturnValue := FMongoStream.Seek(Offset, Origin);
  CheckEquals(AbsExpected, ReturnValue, 'Return value from Seek not what expected');
  CheckEquals(Count - AbsExpected, FMongoStream.Read(Buffer, Count), 'Number of bytes read after first Seek not what expected');
  Check(CompareMem(@Buffer, @PAnsiChar(FEW_BYTES_OF_DATA)[AbsExpected], Count - AbsExpected), 'Data read doesn''t match');
end;
{$ENDIF}

procedure TestTMongoStream.TestStreamStatusFlag;
var
  q : IBson;
  fileid : IBsonOID;
  buf : IBsonBuffer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA)), 'Write didn''t return that I wrote the same amount of bytes written');
  fileid := FMongoStream.ID;
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], False);
  Check(FMongoStream.Status = mssOk, 'Status of file should report OK status');
  FreeAndNil(FMongoStream);
  buf := NewBsonBuffer;
  buf.Append(PAnsiChar('files_id'), fileid);
  q := buf.finish;
  FMongo.remove('fsdb.fs.chunks', q);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], False);
  Check(FMongoStream.Status = mssMissingChunks, 'Status of file should report missing chunks');
end;

procedure TestTMongoStream.TestStressFourThreads;
begin
  InternalRunMultiThreaded(@TestTMongoStream.TestStressWriteReads, 50);
end;

procedure TestTMongoStream.TestStressWriteReads;
const
  RE_WRITE_POS : array [0..5] of integer = (1024, 1024 * 128, 523, 1024 * 256 + 33, 0, 1024 * 100 + 65);
  RE_WRITE_LEN : array [0..5] of integer = ( 512, 1024 * 300, 1024 * 128, 45, 1024 * 64 + 5, 1024 * 313);
var
  Buffer : PAnsiChar;
  i, j : integer;
  ReadBuf : PAnsiChar;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  GetMem(Buffer, FILESIZE);
  try
    GetMem(ReadBuf, FILESIZE);
    try
      for i := 0 to FILESIZE - 1 do
        Buffer[i] := AnsiChar(Random(256));
      CheckEquals(FILESIZE, FMongoStream.Write(Buffer^, FILESIZE), 'Call to Write should have written all data requested');
      FreeAndNil(FMongoStream);
      FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [msmWrite], True); // Reopen the file
      Check(FMongoStream.Status = mssOk, 'Status of file should be mssOk');
      for i := Low(RE_WRITE_POS) to High(RE_WRITE_POS) do
        begin
          FMongoStream.Position := RE_WRITE_POS[i];
          for j := RE_WRITE_POS[i] to RE_WRITE_POS[i] + RE_WRITE_LEN[i] do
            Buffer[j] := AnsiChar(Random(256));
          CheckEquals(RE_WRITE_LEN[i], FMongoStream.Write(Buffer[RE_WRITE_POS[i]], RE_WRITE_LEN[i]), 'Amount of data overriden don''t match count');
          FMongoStream.Position := RE_WRITE_POS[i];
          CheckEquals(RE_WRITE_LEN[i], FMongoStream.Read(ReadBuf^, RE_WRITE_LEN[i]), 'Amount of data read after overriding don''t match');
          Check(CompareMem(@Buffer[RE_WRITE_POS[i]], ReadBuf, RE_WRITE_LEN[i]), 'Data read from stream don''t match data written');
        end;
    finally
      FreeMem(ReadBuf);
    end;
  finally
    FreeMem(Buffer);
  end;
end;

procedure TestTMongoStream.TestWrite;
var
  ReturnValue: Integer;
  Count: Integer;
  Buffer: Pointer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  Buffer := PAnsiChar(FEW_BYTES_OF_DATA);
  ReturnValue := FMongoStream.Write(Buffer, Count);
  CheckEquals(Count, ReturnValue, 'Write didn''t return that I wrote the same amount of bytes written');
end;

procedure TestTMongoStream.TestWriteRead50MB;
type
  PBuffer = ^TBuffer;
  TBuffer = array [0..1024 * 1024 - 1 + 123] of AnsiChar; // I added 123 bytes to "complicate" buffering
const
  FIFTYMEGS = 50 * 1024 * 1024;
var
  ReturnValue: Integer;
  Buffer, Buffer2: PBuffer;
  i : integer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  GetMem(Buffer, sizeof(TBuffer));
  try
    GetMem(Buffer2, sizeof(TBuffer));
    try
      for i := Low(Buffer^) to High(Buffer^) do
        Buffer[i] := AnsiChar(Random(256));
      for I := 0 to FIFTYMEGS div sizeof(Buffer^) do
        begin
          FMongoStream.Position := i * sizeof(TBuffer);
          PInt64(Buffer)^ := i * sizeof(TBuffer);
          FMongoStream.Write(Buffer^, sizeof(Buffer^));
          if i mod 3 = 0 then
            begin
              FMongoStream.Free;
              CreateTestFile(False);
            end;
          if i > 0 then
            begin
              FMongoStream.Position := (i - 1) * sizeof(TBuffer);
              ReturnValue := FMongoStream.Read(Buffer2^, sizeof(TBuffer));
              CheckEquals(Sizeof(Buffer^), ReturnValue, 'Number of bytes read dont''t match');
              PInt64(Buffer)^ := (i - 1) * sizeof(TBuffer);
              Check(CompareMem(Buffer, Buffer2, sizeof(Buffer^)), 'Memory read don''t match data written');
              FMongoStream.Position := (i + 1) * sizeof(TBuffer);
            end;
        end;
      FMongoStream.Position := 0;
      for I := 0 to FIFTYMEGS div sizeof(Buffer^) do
        begin
          ReturnValue := FMongoStream.Read(Buffer2^, sizeof(Buffer^));
          CheckEquals(Sizeof(Buffer^), ReturnValue, 'Number of bytes read dont''t match');
          PInt64(Buffer)^ := i * sizeof(TBuffer);
          Check(CompareMem(Buffer, Buffer2, sizeof(Buffer^)), 'Memory read don''t match data written');
        end;
    finally
      FreeMem(Buffer2);
    end;
  finally
    FreeMem(Buffer);
  end;
end;

procedure TestTMongoStream.TestWriteRed50MBFourThreads;
begin
  InternalRunMultiThreaded(@TestTMongoStream.TestWriteRead50MB, 10);
end;

{ TMongoStreamThread }

constructor TMongoStreamThread.Create(ATestProc: Pointer; ALoops: Integer);
begin
  inherited Create(True);
  FTestMongoStream := TestTMongoStream.Create('TestStressWriteReads');
  FTestProc := ATestProc;
  FLoops := ALoops;
end;

destructor TMongoStreamThread.Destroy;
begin
  FTestMongoStream.Free;
  inherited;
end;

procedure TMongoStreamThread.Execute;
var
  i : integer;
  AMethod : TMethod;
begin
  try
    AMethod.Data := FTestMongoStream;
    AMethod.Code := FTestProc;
    for I := 0 to FLoops - 1 do
      begin
        FTestMongoStream.SetUp;
        TTestProc(AMethod);
        FTestMongoStream.MustDropDatabase := False;
        FTestMongoStream.TearDown;
      end;
  except
    on E : Exception do FErrorMessage := AnsiString(E.Message);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTMongoStream.Suite);
end.

