unit TestuAllocators;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, uAllocators;

type
  // Test methods for class TFixedBlockHeap

  TestTFixedBlockHeap = class(TTestCase)
  private
    FFixedBlockHeap: TFixedBlockHeap;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAlloc;
    procedure TestAllocUntilGetNewPage;
    procedure TestUsingTrackedBlockArrays;
  end;
  // Test methods for class TVariableBlockHeap

  TestTVariableBlockHeap = class(TTestCase)
  private
    FVariableBlockHeap: TVariableBlockHeap;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAlloc;
  end;

implementation

uses
  Classes;

procedure TestTFixedBlockHeap.SetUp;
begin
  FFixedBlockHeap := TFixedBlockHeap.Create(16, 16);
end;

procedure TestTFixedBlockHeap.TearDown;
begin
  FFixedBlockHeap.Free;
  FFixedBlockHeap := nil;
end;

procedure TestTFixedBlockHeap.TestAlloc;
var
  Ptr1 : Pointer;
begin
  Ptr1 := FFixedBlockHeap.Alloc;
  CheckEquals(2, FFixedBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 2');
  FFixedBlockHeap.DeAlloc(Ptr1);
  CheckEquals(1, FFixedBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 1');
end;

procedure TestTFixedBlockHeap.TestAllocUntilGetNewPage;
var
  PtrList : TList;
  i : integer;
  LastResult : Boolean;
begin
  FailsOnMemoryLeak := False; // We know this test will generate a memory leak on purpose
  PtrList := TList.Create;
  try
    PtrList.Add(FFixedBlockHeap.Alloc);
    PtrList.Add(FFixedBlockHeap.Alloc);
    CheckEquals(3, FFixedBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 2');
    while FFixedBlockHeap.CurrentBlockRefCount >= 3 do
      PtrList.Add(FFixedBlockHeap.Alloc);
    CheckEquals(2, FFixedBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 1');
    LastResult := False;
    for I := 0 to PtrList.Count - 2 do
      LastResult := uAllocators.DeAlloc(PtrList[i]);
    Check(LastResult, 'Last block freed should have caused the freeing of the memory block');
  finally
    PtrList.Free;
  end;
end;

procedure TestTFixedBlockHeap.TestUsingTrackedBlockArrays;
var
  PtrList : TList;
  i : integer;
begin
  PtrList := TList.Create;
  try
    FFixedBlockHeap.TrackBlockArrays := True;
    PtrList.Add(FFixedBlockHeap.Alloc);
    PtrList.Add(FFixedBlockHeap.Alloc);
    CheckEquals(3, FFixedBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 2');
    while FFixedBlockHeap.CurrentBlockRefCount >= 3 do
      PtrList.Add(FFixedBlockHeap.Alloc);
    CheckEquals(2, FFixedBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 1');
    for I := 0 to PtrList.Count - 1 do
      FFixedBlockHeap.DeAlloc(PtrList[i]);
  finally
    PtrList.Free;
  end;
end;

procedure TestTVariableBlockHeap.SetUp;
begin
  FVariableBlockHeap := TVariableBlockHeap.Create(512);
end;

procedure TestTVariableBlockHeap.TearDown;
begin
  FVariableBlockHeap.Free;
  FVariableBlockHeap := nil;
end;

procedure TestTVariableBlockHeap.TestAlloc;
var
  Ptr: Pointer;
  ASize: NativeUInt;
begin
  ASize := 128;
  Ptr := FVariableBlockHeap.Alloc(ASize);
  CheckEquals(2, FVariableBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 2');
  FVariableBlockHeap.DeAlloc(Ptr);
  CheckEquals(1, FVariableBlockHeap.CurrentBlockRefCount, 'Reference count of current block should be 1');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTFixedBlockHeap.Suite);
  RegisterTest(TestTVariableBlockHeap.Suite);
end.

