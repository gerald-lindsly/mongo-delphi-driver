unit TestMongoPool;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, MongoDB, MongoPool, TestMongoDB, Classes;

type
  // Test methods for class TMongoPool
  TestTMongoPool = class(TestMongoBase)
  private
    FMongoPool: TMongoPool;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAcquireWithHostName;
    procedure TestAcquireWithoutParams;
    procedure TestAcquireWithHostNameTwice;
    procedure TestAcquireWithHostNameAndPassword;
    procedure TestAcquireWithPoolPointer;
    procedure TestMultiThreaded;
    procedure TestRelease;
    procedure TestReleaseWithConnStr;
    procedure TestReleaseWithHostNameUsrNameAndPassword;
  end;

implementation

uses
  Windows, SysUtils, MongoBson;

type
  TMongoPoolThread = class(TThread)
  private
    FErrorMessage: AnsiString;
    FPool: TMongoPool;
    procedure Error(const AMsg: AnsiString);
  public
    constructor Create(APool: TMongoPool);
    procedure Execute; override;
    property ErrorMessage: AnsiString read FErrorMessage write FErrorMessage;
  end;

procedure TestTMongoPool.SetUp;
begin
  inherited;
  FMongoPool := TMongoPool.Create;
end;

procedure TestTMongoPool.TearDown;
begin
  FMongoPool.Free;
  FMongoPool := nil;
  RemoveUser('test_user_thread', 'test_usr_pwd');
  RemoveUser('testuser', 'testpwd');
  inherited;
end;

procedure TestTMongoPool.TestAcquireWithHostName;
var
  ReturnValue: TMongoPooledRecord;
  AHostName: AnsiString;
begin
  AHostName := '127.0.0.1';
  ReturnValue := FMongoPool.Acquire(AHostName);
  Check(ReturnValue.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(ReturnValue);
end;

procedure TestTMongoPool.TestAcquireWithoutParams;
var
  ReturnValue: TMongoPooledRecord;
begin
  ReturnValue := FMongoPool.Acquire;
  Check(ReturnValue.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(ReturnValue);
end;

procedure TestTMongoPool.TestAcquireWithHostNameTwice;
var
  ReturnValue: TMongoPooledRecord;
  AHostName: AnsiString;
begin
  AHostName := '127.0.0.1';
  ReturnValue := FMongoPool.Acquire(AHostName);
  Check(ReturnValue.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(ReturnValue);
  ReturnValue := FMongoPool.Acquire(AHostName);
  Check(ReturnValue.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(ReturnValue);
end;

procedure TestTMongoPool.TestAcquireWithHostNameAndPassword;
var
  ReturnValue: TMongoPooledRecord;
  APassword: AnsiString;
  AUserName: AnsiString;
  AHostName: AnsiString;
  AMongo : TMongo;
begin
  AHostName := '127.0.0.1';
  AUserName := 'testuser';
  APassword := 'testpwd';
  ReturnValue := FMongoPool.Acquire(AHostName);
  AMongo := ReturnValue.Mongo;
  Check(AMongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  Check(AMongo.addUser(AUserName, APassword), 'Call to addUser should return true');
  ReturnValue := FMongoPool.Acquire(AHostName, AUserName, APassword);
  Check(ReturnValue.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(ReturnValue);
  FMongoPool.Release(ReturnValue.Pool, AMongo);
end;

procedure TestTMongoPool.TestAcquireWithPoolPointer;
var
  ReturnValue: TMongoPooledRecord;
  AHostName: AnsiString;
  AOtherMongo : TMongo;
begin
  AHostName := '127.0.0.1';
  ReturnValue := FMongoPool.Acquire(AHostName);
  Check(ReturnValue.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  AOtherMongo := FMongoPool.Acquire(ReturnValue.Pool);
  Check(AOtherMongo <> nil, 'Call to FMongoPool.Acquire with pool pointer must return <> nil');
  FMongoPool.Release(ReturnValue);
  FMongoPool.Release(ReturnValue.Pool, AOtherMongo);
end;

procedure TestTMongoPool.TestMultiThreaded;
var
  Threads : array [0..3] of TMongoPoolThread;
  i : integer;
  APoolRecord : TMongoPooledRecord;
begin
  APoolRecord := FMongoPool.Acquire;
  try
    APoolRecord.Mongo.addUser('test_user_thread', 'test_usr_pwd');
    for i := Low(Threads) to High(Threads) do
      Threads[i] := TMongoPoolThread.Create(FMongoPool);
    try
      for i := Low(Threads) to High(Threads) do
        Threads[i].Resume;
      for i := Low(Threads) to High(Threads) do
        Threads[i].WaitFor;
      for i := Low(Threads) to High(Threads) do
        if Threads[i].ErrorMessage <> ''
          then Fail(Threads[i].ErrorMessage);
    finally
      for i := Low(Threads) to High(Threads) do
        Threads[i].Free;
    end;
  finally
    FMongoPool.Release(APoolRecord);
  end;
end;

procedure TestTMongoPool.TestRelease;
var
  AHostName : AnsiString;
  APoolRecord : TMongoPooledRecord;
begin
  AHostName := '127.0.0.1';
  APoolRecord := FMongoPool.Acquire(AHostName);
  Check(APoolRecord.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(APoolRecord);
end;

procedure TestTMongoPool.TestReleaseWithConnStr;
var
  AHostName : AnsiString;
  APoolRecord : TMongoPooledRecord;
begin
  AHostName := '127.0.0.1';
  APoolRecord := FMongoPool.Acquire(AHostName);
  Check(APoolRecord.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(AHostName, APoolRecord.Mongo);
end;

procedure TestTMongoPool.TestReleaseWithHostNameUsrNameAndPassword;
var
  AHostName : AnsiString;
  APoolRecord : TMongoPooledRecord;
  AMongo : TMongo;
begin
  AHostName := '127.0.0.1';
  APoolRecord := FMongoPool.Acquire(AHostName);
  AMongo := APoolRecord.Mongo;
  Check(AMongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  AMongo.addUser('test', 'test');
  APoolRecord := FMongoPool.Acquire(AHostName, 'test', 'test');
  Check(APoolRecord.Mongo <> nil, 'Call to FMongoPool.Acquire should return value <> nil');
  FMongoPool.Release(AHostName, '', '', AMongo);
  FMongoPool.Release(AHostName, 'test', 'test', APoolRecord.Mongo);
end;

constructor TMongoPoolThread.Create(APool: TMongoPool);
begin
  inherited Create(True);
  FPool := APool;
end;

procedure TMongoPoolThread.Error(const AMsg: AnsiString);
begin
  FErrorMessage := AMsg;
  abort;
end;

procedure TMongoPoolThread.Execute;
var
  APoolRecord : TMongoPooledRecord;
  i : integer;
begin
  try
    for I := 0 to 500 do
      begin
        APoolRecord := FPool.Acquire('127.0.0.1', 'test_user_thread', 'test_usr_pwd');
        if APoolRecord.Mongo = nil then
          Error('Mongo = nil');
        if not APoolRecord.Mongo.authenticate('test_user_thread', 'test_usr_pwd') then
          Error('Failed authentication');
        Sleep(5);
        FPool.Release(APoolRecord);
      end;
  except
    on EAbort do {};
    on E : Exception do FErrorMessage := AnsiString(E.Message);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTMongoPool.Suite);
end.

